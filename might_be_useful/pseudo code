pseudo code of self-embedding watermarking algorithm

> załaduj obraz I jako macierz I[x,y]
> ustaw wszystkie dwa najstarsze bity na zero
> podziel obraz I na niepokrywające się bloki o wymiarach 8x8 i nazwij je A[i,j], gdzie [i,j] to indeks bloku (i<x/8 oraz j<y/8)
> podziel obraz I na ćwiartki oznacz je wg schematu
	 Q3 | Q0
	----+----
	 Q2 | Q1
> wykonaj kompresję fraktalną na każdej ćwiartce względem jej ćwiatki diagonalnej.
	- weź bloki R z Q0 i szukaj najlepiej dopasowanych bloków D z Q2
	- weź bloki R z Q1 i szukaj najlepiej dopasowanych bloków D z Q3
	- weź bloki R z Q2 i szukaj najlepiej dopasowanych bloków D z Q0
	- weź bloki R z Q3 i szukaj najlepiej dopasowanych bloków D z Q1
	- dla każdego R wyniki zapisz w postaci 32 bitów:
		x(7b), y(7b), t(3b), s(7b), o(8b)
> przesuń obraz I o 4 piksele w górę zawijając górne piksele do dołu. wynik zapisz jako I'
> podziel obraz I' na niepokrywające się bloku o wymiarach 8x8 i nazwij je B[i,j]
> przekształć każdy blok B[i,j] do dziedziny częstotliwości wykorzystując DCT. wynik nadpisz
> ??? zrób jakąś magię z tablicą kwantyzacji JPEG 
> przesuń oryginalny obraz I o 4 piksele w lewo zawijając lewe piksele do prawej strony. wynik zapisz jako I''
> podziel obraz I'' na niepokrywające się bloki o wymiarach 8x8 i nazwij je C[i,j]
> ??? zrób tę samą magię z tablicą kwantyzacji JPEG
> dla każdego z podziałów znajdź bloki mapujące:
	- dla A[i,j]
> 